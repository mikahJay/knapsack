name: CI / Build & Deploy

on:
  push:
    branches: [ main, deploy ]
  workflow_dispatch:
    inputs:
      deploy_target:
        description: "Service to deploy"
        required: false
        default: "all"
        type: choice
        options:
          - all
          - resource-server
          - need-server
          - auth-server
          - web-app

jobs:
  prepare:
    name: Prepare infra & repos
    runs-on: ubuntu-latest
    outputs:
      alb_dns: ${{ steps.export_alb.outputs.alb_dns }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      
      # (Removed change-detection steps; deploy will run unconditionally)
      

      

      
 

      

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: latest

      - name: Ensure ECR repositories exist
        run: |
          for repo in need-server-test resource-server-test auth-server-test web-app-test; do
            if ! aws ecr describe-repositories --repository-names "$repo" >/dev/null 2>&1; then
              aws ecr create-repository --repository-name "$repo"
            fi
          done

      - name: Terraform init & network + DB apply
        run: |
          terraform -chdir=infra/terraform init -input=false -reconfigure || { echo "terraform init failed"; exit 1; }
          terraform -chdir=infra/terraform apply -lock-timeout=300s -var="environment=test" \
            -target=aws_vpc.knapsack \
            -target=aws_internet_gateway.igw \
            -target=aws_subnet.public \
            -target=aws_subnet.private \
            -target=aws_route_table.public \
            -target=aws_route_table_association.public \
            -target=aws_route_table.private \
            -target=aws_route_table_association.private \
            -target=aws_security_group.service_sg \
            -target=aws_security_group.nat_sg \
            -target=aws_instance.nat \
            -target=aws_lb.alb \
            -target=aws_lb_target_group.need_server_tg \
            -target=aws_lb_target_group.resource_server_tg \
            -target=aws_lb_target_group.auth_server_tg \
            -target=aws_lb_target_group.web_app_tg \
            -target=aws_lb_listener.http \
            -target=aws_lb_listener.http \
            -target=aws_lb_listener_rule.resource_path \
            -target=aws_lb_listener_rule.auth_path \
            -target=aws_lb_listener_rule.web_path \
            -target=aws_vpc_endpoint.secretsmanager \
            -target=aws_db_subnet_group.knapsack \
            -target=aws_security_group.rds_sg \
            -target=aws_db_instance.knapsack \
            -target=aws_secretsmanager_secret.db_credentials \
            -target=aws_secretsmanager_secret_version.db_credentials_ver \
            -auto-approve || echo "network/DB apply exited non-zero"

      - name: Export ALB DNS for builds
        id: export_alb
        run: |
          set -euo pipefail
          ALB_RAW=$(terraform -chdir=infra/terraform output -raw alb_dns_name 2>/dev/null || true)
          ALB=$(printf "%s\n" "$ALB_RAW" | grep -oE '([a-z0-9-]+\.elb\.amazonaws\.com)' | head -n1 || true)
          if [ -z "${ALB}" ]; then
            echo "alb_dns=" >> $GITHUB_OUTPUT
            echo "Warning: ALB_DNS not found from terraform output" >&2
          else
            echo "alb_dns=${ALB}" >> $GITHUB_OUTPUT
            echo "ALB_DNS set to ${ALB}"
          fi

  deploy:
    name: Build & Deploy services
    needs: prepare
    runs-on: ubuntu-latest
    env:
      DEPLOY_TARGET: ${{ github.event.inputs.deploy_target || 'all' }}
    strategy:
      fail-fast: false
      max-parallel: 1  # Serialize to avoid Terraform lock conflicts
      matrix:
        include:
          - name: need-server
            repo: need-server-test
            context: services/need-server
            tf_name: need_server
          - name: resource-server
            repo: resource-server-test
            context: services/resource-server
            tf_name: resource_server
          - name: auth-server
            repo: auth-server-test
            context: services/auth-server
            tf_name: auth_server
          - name: web-app
            repo: web-app-test
            context: apps/web-app
            tf_name: web_app
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Clean stuck ECS tasks (pending)
        run: |
          set -euo pipefail
          CLUSTER=knapsack-test
          echo "Looking for PENDING tasks in cluster $CLUSTER"
          TASK_ARNS=$(aws ecs list-tasks --cluster "$CLUSTER" --desired-status PENDING --region ${{ secrets.AWS_REGION }} --output text || true)
          if [ -z "$TASK_ARNS" ] || [ "$TASK_ARNS" = "None" ]; then
            echo "No PENDING tasks found"
          else
            for TASK in $TASK_ARNS; do
              LAST=$(aws ecs describe-tasks --cluster "$CLUSTER" --tasks "$TASK" --region ${{ secrets.AWS_REGION }} --query 'tasks[0].lastStatus' --output text || echo "UNKNOWN")
              echo "Task $TASK lastStatus=$LAST"
              if [ "$LAST" != "RUNNING" ]; then
                echo "Stopping task $TASK (status $LAST)"
                aws ecs stop-task --cluster "$CLUSTER" --task "$TASK" --reason "CI cleanup: stopping non-running task" --region ${{ secrets.AWS_REGION }} || true
              fi
            done
          fi

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and push image
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        
        uses: docker/build-push-action@v4
        with:
          context: ${{ matrix.context }}
          push: true
          tags: |
            ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ matrix.repo }}:${{ github.sha }}
            ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ matrix.repo }}:latest

      - name: Export deploy variables
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        
        run: |
          echo "TF_VAR_image_tag=${GITHUB_SHA}" >> $GITHUB_ENV
          echo "TF_VAR_google_client_id=${{ secrets.GOOGLE_CLIENT_ID }}" >> $GITHUB_ENV

      - name: Setup Terraform
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: latest

      - name: Terraform init
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        run: terraform -chdir=infra/terraform init -input=false -reconfigure

      - name: Import existing ECR repo into state (if present)
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        
        run: |
          if aws ecr describe-repositories --repository-names "${{ matrix.repo }}" >/dev/null 2>&1; then
            terraform -chdir=infra/terraform state list aws_ecr_repository.${{ matrix.tf_name }} >/dev/null 2>&1 || terraform -chdir=infra/terraform import aws_ecr_repository.${{ matrix.tf_name }} ${{ matrix.repo }} || echo "terraform import ${matrix.repo} failed"
          fi

      - name: Ensure ECS cluster + service exist and redeploy
        if: ${{ env.DEPLOY_TARGET == 'all' || env.DEPLOY_TARGET == matrix.name }}
        
        run: |
          set -euo pipefail

          # Check if service exists and is in a bad state (INACTIVE, DRAINING)
          SERVICE_STATUS=$(aws ecs describe-services --cluster knapsack-test --services ${{ matrix.name }}-test --region ${{ secrets.AWS_REGION }} --query 'services[0].status' --output text 2>/dev/null || echo "NOTFOUND")
          
          if [ "$SERVICE_STATUS" != "ACTIVE" ] && [ "$SERVICE_STATUS" != "NOTFOUND" ]; then
            echo "Service is in $SERVICE_STATUS state; force deleting and will recreate..."
            aws ecs delete-service --cluster knapsack-test --service ${{ matrix.name }}-test --region ${{ secrets.AWS_REGION }} --force || true
            # Wait for deletion to complete
            echo "Waiting for service deletion to complete..."
            sleep 30
            SERVICE_STATUS="NOTFOUND"
          fi

          # Try to trigger a redeploy first (service may already exist)
          OUT=$(aws ecs update-service --cluster knapsack-test --service ${{ matrix.name }}-test --force-new-deployment 2>&1) || true

          if echo "$OUT" | grep -q "ServiceNotFoundException" || [ "$SERVICE_STATUS" = "NOTFOUND" ]; then
            echo "${{ matrix.name }} service not found; running Terraform to create cluster, task def and service..."
            # Ensure CloudWatch log group exists first
            terraform -chdir=infra/terraform apply -lock-timeout=300s -var="environment=test" -target=aws_cloudwatch_log_group.${{ matrix.tf_name }} -auto-approve || echo "Log group may already exist"
            # Create cluster, task definition, and service
            terraform -chdir=infra/terraform apply -lock-timeout=300s -var="environment=test" -target=aws_ecs_cluster.knapsack -target=aws_ecs_task_definition.${{ matrix.tf_name }} -target=aws_ecs_service.${{ matrix.tf_name }} -auto-approve || { echo "terraform apply exited non-zero"; exit 1; }

            # Find latest task definition ARN for the family and update service
            FAMILY="${{ matrix.name }}-test"
            # Request the list and robustly extract the first arn:aws:ecs: token (guard against header/None/newlines)
            TD_ARN_RAW=$(aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 5 --region ${{ secrets.AWS_REGION }} --query 'taskDefinitionArns' --output text || true)
            TD_ARN=$(printf "%s" "$TD_ARN_RAW" | tr -d '\r' | tr ' ' '\n' | grep -m1 -E '^arn:aws:ecs:' || true)
            if [ -n "$TD_ARN" ]; then
              # Verify the selected task definition is ACTIVE
              TD_STATUS=$(aws ecs describe-task-definition --task-definition "$TD_ARN" --region ${{ secrets.AWS_REGION }} --query 'taskDefinition.status' --output text 2>/dev/null || true)
              if [ "$TD_STATUS" != "ACTIVE" ]; then
                echo "Selected task definition is not ACTIVE: status=$TD_STATUS"
                echo "Available ACTIVE task definitions for $FAMILY:"
                aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 10 --region ${{ secrets.AWS_REGION }} --output text || true
                exit 1
              fi
              # Ensure the newly registered task definition is available, then update the service
              ATTEMPTS=0
              MAX_ATTEMPTS=6
              UPDATED=0
              until [ $ATTEMPTS -ge $MAX_ATTEMPTS ]
              do
                ATTEMPTS=$((ATTEMPTS+1))
                echo "Checking availability of task definition (attempt $ATTEMPTS/$MAX_ATTEMPTS): $TD_ARN"
                if aws ecs describe-task-definition --task-definition "$TD_ARN" --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
                  echo "Task definition available; attempting update-service"
                  if aws ecs update-service --cluster knapsack-test --service ${{ matrix.name }}-test --task-definition "$TD_ARN" --force-new-deployment --region ${{ secrets.AWS_REGION }}; then
                    UPDATED=1
                    break
                  else
                    echo "aws ecs update-service failed; retrying after backoff"
                  fi
                else
                  echo "Task definition not yet visible to ECS API; retrying after backoff"
                fi
                sleep $((ATTEMPTS * 2))
              done
              if [ "$UPDATED" -ne 1 ]; then
                echo "update-service failed after ${MAX_ATTEMPTS} attempts"
                echo "TD_ARN=[$TD_ARN]"
                aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 5 --region ${{ secrets.AWS_REGION }} --output text || true
                exit 1
              fi
            else
              echo "No task definition found for family $FAMILY"
            fi

          elif echo "$OUT" | grep -q "ClusterNotFoundException"; then
            echo "Cluster unexpectedly missing after create: $OUT"

          else
            # Service exists; register a new task definition revision (via Terraform) with the new image, then force deployment
            echo "Service exists; registering new task definition revision via Terraform..."
            # Retry terraform apply for task definition to handle transient DynamoDB lock errors
            ATTEMPTS=0
            MAX_ATTEMPTS=5
            until [ $ATTEMPTS -ge $MAX_ATTEMPTS ]
            do
              ATTEMPTS=$((ATTEMPTS+1))
              echo "Running terraform apply (attempt $ATTEMPTS/$MAX_ATTEMPTS)"
              if terraform -chdir=infra/terraform apply -lock-timeout=300s -var="environment=test" -target=aws_ecs_task_definition.${{ matrix.tf_name }} -auto-approve; then
                break
              fi
              echo "terraform apply failed (attempt $ATTEMPTS). Retrying after backoff..."
              sleep $((ATTEMPTS * 10))
            done
            if [ $ATTEMPTS -ge $MAX_ATTEMPTS ]; then
              echo "terraform apply for task_definition failed after $MAX_ATTEMPTS attempts"
              exit 1
            fi

            # Determine newest task definition ARN for the family and update the service explicitly
            FAMILY="${{ matrix.name }}-test"
            # Request the list and robustly extract the first arn:aws:ecs: token (guard against header/None/newlines)
            TD_ARN_RAW=$(aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 5 --region ${{ secrets.AWS_REGION }} --query 'taskDefinitionArns' --output text || true)
            TD_ARN=$(printf "%s" "$TD_ARN_RAW" | tr -d '\r' | tr ' ' '\n' | grep -m1 -E '^arn:aws:ecs:' || true)
            if [ -n "$TD_ARN" ]; then
              # Verify the selected task definition is ACTIVE
              TD_STATUS=$(aws ecs describe-task-definition --task-definition "$TD_ARN" --region ${{ secrets.AWS_REGION }} --query 'taskDefinition.status' --output text 2>/dev/null || true)
              if [ "$TD_STATUS" != "ACTIVE" ]; then
                echo "Selected task definition is not ACTIVE: status=$TD_STATUS"
                echo "Available ACTIVE task definitions for $FAMILY:"
                aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 10 --region ${{ secrets.AWS_REGION }} --output text || true
                exit 1
              fi
              echo "Updating service to use $TD_ARN"
              # Retry describe + update to guard against eventual consistency
              ATTEMPTS=0
              MAX_ATTEMPTS=6
              UPDATED=0
              until [ $ATTEMPTS -ge $MAX_ATTEMPTS ]
              do
                ATTEMPTS=$((ATTEMPTS+1))
                echo "Checking task definition visibility (attempt $ATTEMPTS/$MAX_ATTEMPTS): $TD_ARN"
                if aws ecs describe-task-definition --task-definition "$TD_ARN" --region ${{ secrets.AWS_REGION }} >/dev/null 2>&1; then
                  if aws ecs update-service --cluster knapsack-test --service ${{ matrix.name }}-test --task-definition "$TD_ARN" --force-new-deployment --region ${{ secrets.AWS_REGION }}; then
                    UPDATED=1
                    break
                  else
                    echo "aws ecs update-service failed; will retry"
                  fi
                else
                  echo "Task definition not yet visible; will retry"
                fi
                sleep $((ATTEMPTS * 2))
              done
              if [ "$UPDATED" -ne 1 ]; then
                echo "update-service failed after ${MAX_ATTEMPTS} attempts"
                echo "TD_ARN=[$TD_ARN]"
                aws ecs list-task-definitions --family-prefix "$FAMILY" --status ACTIVE --sort DESC --max-items 5 --region ${{ secrets.AWS_REGION }} --output text || true
                exit 1
              fi

              echo "Waiting for service to become stable..."
              if ! aws ecs wait services-stable --cluster knapsack-test --services ${{ matrix.name }}-test --region ${{ secrets.AWS_REGION }} --no-paginate; then
                echo "Service did not stabilize; dumping events and recent logs"
                aws ecs describe-services --cluster knapsack-test --services ${{ matrix.name }}-test --region ${{ secrets.AWS_REGION }} --output json | jq .
                echo "Recent CloudWatch logs (last 30m):"
                aws logs tail /ecs/${{ matrix.name }}-test --region ${{ secrets.AWS_REGION }} --since 30m || true
                exit 1
              fi
            else
              echo "No task definition found for family $FAMILY"
            fi
          fi

          # Post-deploy runtime config check (web-app only)
          if [ "${{ matrix.name }}" = "web-app" ]; then
            ALB_DOMAIN="${{ needs.prepare.outputs.alb_dns }}"
            if [ -z "$ALB_DOMAIN" ]; then
              echo "ALB domain unknown; skipping runtime env-config.js check"
            else
              URL="https://${ALB_DOMAIN}/env-config.js"
              echo "Checking runtime config at $URL"
              if ! curl -sfS "$URL" -o /tmp/env-config.js; then
                echo "Failed to fetch env-config.js at $URL"
                exit 1
              fi
              # Fail if VITE_GOOGLE_CLIENT_ID is empty
              if grep -qE 'VITE_GOOGLE_CLIENT_ID: \"\"' /tmp/env-config.js; then
                echo "VITE_GOOGLE_CLIENT_ID is empty in env-config.js"
                cat /tmp/env-config.js
                exit 1
              fi
              echo "Runtime env-config.js contains VITE_GOOGLE_CLIENT_ID"
            fi
          fi
